{"ast":null,"code":"// import * as redux from \"redux\";\n// import { createStore } from \"redux\";\nimport { configureStore, createSlice } from \"@reduxjs/toolkit\";\nconst initialCounterState = {\n  counter: 0,\n  showCounter: true\n};\n\n/*\n// NOTE: Without using redux toolkit:\nconst counterReducer = (state = initialState, action) => {\n  if (action.type === \"inc\") return { counter: state.counter + 1, showCounter: state.showCounter };\n  else if (action.type === \"dec\") return { counter: state.counter - 1, showCounter: state.showCounter };\n  else if (action.type === \"increase\")\n    return { counter: state.counter + action.amount, showCounter: state.showCounter };\n  else if (action.type === \"toggle\") return { ...state, showCounter: !state.showCounter };\n  return state; // No changes if no match\n};\n\nconst store = createStore(counterReducer);\n*/\n\nconst counterSlice = createSlice({\n  name: \"counter\",\n  initialState: initialCounterState,\n  reducers: {\n    increment: state => {\n      state.counter++; // NOTE: if state is being modified, need to wrap within {} for the enclosing function\n    },\n    decrement: state => {\n      state.counter--; // Wrap within {} as state is being modified\n    },\n    increase: (state, action) => {\n      state.counter += action.payload.amount;\n    },\n    toggleCounter: state => ({\n      ...state,\n      showCounter: !state.showCounter\n    })\n    // Here, we're returning a new state snapshow, hence no need of enclosing {} for the function\n  }\n});\nconst initialAuthState = {\n  isAuthenticated: false\n};\nconst authSlice = createSlice({\n  name: \"auth\",\n  initialState: initialAuthState,\n  reducers: {\n    logIn: state => ({\n      isAuthenticated: true\n    }),\n    logOut: state => ({\n      isAuthenticated: false\n    })\n  }\n});\n\n// If there's only one reducer in the entire application:\n// const store = configureStore({ reducer: counterSlice.reducer });\n// For multiple reducers, specify as follows and configureStore will merge all reducers:\nconst store = configureStore({\n  reducer: {\n    counter: counterSlice.reducer,\n    auth: authSlice.reducer\n  }\n});\n\n// Exporting actions to be used in dispatch functions:\nexport const counterActions = counterSlice.actions; // to be used in Counter.js in dispatch function calls\nexport const authActions = authSlice.actions; // to be used in Auth.js in dispatch function calls\n\n// Export default store:\nexport default store; // To be used in <Provider> (index.js)","map":{"version":3,"names":["configureStore","createSlice","initialCounterState","counter","showCounter","counterSlice","name","initialState","reducers","increment","state","decrement","increase","action","payload","amount","toggleCounter","initialAuthState","isAuthenticated","authSlice","logIn","logOut","store","reducer","auth","counterActions","actions","authActions"],"sources":["/Users/ankush/Library/CloudStorage/OneDrive-Personal/Dev/Academind/React/12-React-Redux/src/store/index.js"],"sourcesContent":["// import * as redux from \"redux\";\n// import { createStore } from \"redux\";\nimport { configureStore, createSlice } from \"@reduxjs/toolkit\";\n\nconst initialCounterState = { counter: 0, showCounter: true };\n\n/*\n// NOTE: Without using redux toolkit:\nconst counterReducer = (state = initialState, action) => {\n  if (action.type === \"inc\") return { counter: state.counter + 1, showCounter: state.showCounter };\n  else if (action.type === \"dec\") return { counter: state.counter - 1, showCounter: state.showCounter };\n  else if (action.type === \"increase\")\n    return { counter: state.counter + action.amount, showCounter: state.showCounter };\n  else if (action.type === \"toggle\") return { ...state, showCounter: !state.showCounter };\n  return state; // No changes if no match\n};\n\nconst store = createStore(counterReducer);\n*/\n\nconst counterSlice = createSlice({\n  name: \"counter\",\n  initialState: initialCounterState,\n  reducers: {\n    increment: (state) => {\n      state.counter++; // NOTE: if state is being modified, need to wrap within {} for the enclosing function\n    },\n    decrement: (state) => {\n      state.counter--; // Wrap within {} as state is being modified\n    },\n    increase: (state, action) => {\n      state.counter += action.payload.amount;\n    },\n    toggleCounter: (state) => ({ ...state, showCounter: !state.showCounter }),\n    // Here, we're returning a new state snapshow, hence no need of enclosing {} for the function\n  },\n});\n\nconst initialAuthState = {\n  isAuthenticated: false,\n};\n\nconst authSlice = createSlice({\n  name: \"auth\",\n  initialState: initialAuthState,\n  reducers: {\n    logIn: (state) => ({ isAuthenticated: true }),\n    logOut: (state) => ({ isAuthenticated: false }),\n  },\n});\n\n// If there's only one reducer in the entire application:\n// const store = configureStore({ reducer: counterSlice.reducer });\n// For multiple reducers, specify as follows and configureStore will merge all reducers:\nconst store = configureStore({ reducer: { counter: counterSlice.reducer, auth: authSlice.reducer } });\n\n// Exporting actions to be used in dispatch functions:\nexport const counterActions = counterSlice.actions; // to be used in Counter.js in dispatch function calls\nexport const authActions = authSlice.actions; // to be used in Auth.js in dispatch function calls\n\n// Export default store:\nexport default store; // To be used in <Provider> (index.js)\n"],"mappings":"AAAA;AACA;AACA,SAASA,cAAc,EAAEC,WAAW,QAAQ,kBAAkB;AAE9D,MAAMC,mBAAmB,GAAG;EAAEC,OAAO,EAAE,CAAC;EAAEC,WAAW,EAAE;AAAK,CAAC;;AAE7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAMC,YAAY,GAAGJ,WAAW,CAAC;EAC/BK,IAAI,EAAE,SAAS;EACfC,YAAY,EAAEL,mBAAmB;EACjCM,QAAQ,EAAE;IACRC,SAAS,EAAGC,KAAK,IAAK;MACpBA,KAAK,CAACP,OAAO,EAAE,CAAC,CAAC;IACnB,CAAC;IACDQ,SAAS,EAAGD,KAAK,IAAK;MACpBA,KAAK,CAACP,OAAO,EAAE,CAAC,CAAC;IACnB,CAAC;IACDS,QAAQ,EAAEA,CAACF,KAAK,EAAEG,MAAM,KAAK;MAC3BH,KAAK,CAACP,OAAO,IAAIU,MAAM,CAACC,OAAO,CAACC,MAAM;IACxC,CAAC;IACDC,aAAa,EAAGN,KAAK,KAAM;MAAE,GAAGA,KAAK;MAAEN,WAAW,EAAE,CAACM,KAAK,CAACN;IAAY,CAAC;IACxE;EACF;AACF,CAAC,CAAC;AAEF,MAAMa,gBAAgB,GAAG;EACvBC,eAAe,EAAE;AACnB,CAAC;AAED,MAAMC,SAAS,GAAGlB,WAAW,CAAC;EAC5BK,IAAI,EAAE,MAAM;EACZC,YAAY,EAAEU,gBAAgB;EAC9BT,QAAQ,EAAE;IACRY,KAAK,EAAGV,KAAK,KAAM;MAAEQ,eAAe,EAAE;IAAK,CAAC,CAAC;IAC7CG,MAAM,EAAGX,KAAK,KAAM;MAAEQ,eAAe,EAAE;IAAM,CAAC;EAChD;AACF,CAAC,CAAC;;AAEF;AACA;AACA;AACA,MAAMI,KAAK,GAAGtB,cAAc,CAAC;EAAEuB,OAAO,EAAE;IAAEpB,OAAO,EAAEE,YAAY,CAACkB,OAAO;IAAEC,IAAI,EAAEL,SAAS,CAACI;EAAQ;AAAE,CAAC,CAAC;;AAErG;AACA,OAAO,MAAME,cAAc,GAAGpB,YAAY,CAACqB,OAAO,CAAC,CAAC;AACpD,OAAO,MAAMC,WAAW,GAAGR,SAAS,CAACO,OAAO,CAAC,CAAC;;AAE9C;AACA,eAAeJ,KAAK,CAAC,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}